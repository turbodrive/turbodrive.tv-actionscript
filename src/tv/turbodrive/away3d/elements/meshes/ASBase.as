//Generated by Prefab3D 2.133, Fri Jan 25 21:20:53 GMT+0100 2013. www.closier.nl/prefab
package tv.turbodrive.away3d.elements.meshes
{
	import away3d.entities.Mesh;
	import away3d.containers.ObjectContainer3D;
	import away3d.core.base.Geometry;
	import away3d.core.base.SubGeometry;
	import away3d.materials.ColorMaterial;
	import away3d.textures.BitmapCubeTexture;
	import away3d.materials.methods.EffectMethodBase;
	import away3d.materials.methods.EnvMapMethod;
	import away3d.materials.SinglePassMaterialBase;
	import away3d.textures.BitmapTexture;
	import away3d.textures.Texture2DBase;
	import away3d.materials.TextureMaterial;
	import away3d.materials.MaterialBase;
	import away3d.loaders.AssetLoader;
	import away3d.materials.utils.DefaultMaterialManager;
	import away3d.events.AssetEvent;
	import flash.net.URLRequest;
	import flash.display.BitmapData;
	import flash.geom.Matrix3D;

	public class ASBase extends ObjectContainer3D
	{
		protected var _materials:Vector.<MaterialBase>;
		protected var _containers:Vector.<ObjectContainer3D>;
		protected var _meshes:Vector.<Mesh>;
		protected var _animators:Array;

		function ASBase ():void
		{
			_containers = new Vector.<ObjectContainer3D>();
			_materials = new Vector.<MaterialBase>();
			_meshes = new Vector.<Mesh>();
			_animators = [];
		}

		protected function getMaterialFromID(id:String):MaterialBase
		{
			for(var i:uint = 0;i<_materials.length;++i){
				if(_materials[i].name == id)
					return _materials[i];
			}

			return null;
		}

		protected function generateMaterial(id:String, color:uint = NaN, bmd:BitmapData=null, url:String = ""):MaterialBase
		{
			var material:MaterialBase = (bmd)? buildTextureMaterial(bmd) : (url == "")? buildColorMaterial(color) : prepareTextureMaterial(url);
			material.name = id;
			_materials.push(material);
			return material;
		}

		protected function buildColorMaterial(color:uint):ColorMaterial
		{
			var colorMaterial:ColorMaterial = new ColorMaterial(color);
			return colorMaterial;
		}

		protected function loadEnvMapMethod(id:String, alpha:Number, url0:String, url1:String, url2:String, url3:String, url4:String, url5:String):EnvMapMethod
		{
			var bmd:BitmapData = new BitmapData(64,64, false, 0xCCCCCC);
			var bitmapCubeTexture:BitmapCubeTexture = new BitmapCubeTexture(bmd,bmd,bmd,bmd,bmd,bmd);
			bitmapCubeTexture.name = id;
			var envMap:EnvMapMethod = new EnvMapMethod(bitmapCubeTexture, alpha);

			loadDependency(url0, onBitmapDataComplete);
			loadDependency(url1, onBitmapDataComplete);
			loadDependency(url2, onBitmapDataComplete);
			loadDependency(url3, onBitmapDataComplete);
			loadDependency(url4, onBitmapDataComplete);
			loadDependency(url5, onBitmapDataComplete);

			return envMap;
		}

		private function onBitmapDataComplete(e:AssetEvent):void
		{
			AssetLoader(e.currentTarget).removeEventListener(AssetEvent.ASSET_COMPLETE, onAssetComplete);
			finalizeEnvMapMethod(e.assetPrevName, BitmapTexture(e.asset).bitmapData);
		}

		private function finalizeEnvMapMethod(id:String, bitmapData:BitmapData):void
		{
			var sp:SinglePassMaterialBase;
			var j:uint;
			var split:Array = id.split("/");
			split = split[split.length-1].split(".");
			var shortid:String = split[0];
			var index:String = shortid.substring(0, shortid.length-4);
			var method:EffectMethodBase;
			var bitmapCubeTexture:BitmapCubeTexture;
			for(var i:uint = 0;i<_materials.length;++i){
				sp = SinglePassMaterialBase(_materials[i]);
				if(sp.numMethods != 0){
					for(j = 0;j<sp.numMethods;++j){
						method = sp.getMethodAt(j);
						if(method is EnvMapMethod && EnvMapMethod(method).envMap.name.substring(0, index.length) == index){
							bitmapCubeTexture = BitmapCubeTexture(EnvMapMethod(method).envMap);
							switch(shortid.substring(shortid.length-1,shortid.length)){
								case "0":
									bitmapCubeTexture.positiveX = bitmapData;
								break;
								case "1":
									bitmapCubeTexture.negativeX = bitmapData;
								break;
								case "2":
									bitmapCubeTexture.positiveY = bitmapData;
								break;
								case "3":
									bitmapCubeTexture.negativeY = bitmapData;
								break;
								case "4":
									bitmapCubeTexture.positiveZ = bitmapData;
								break;
								case "5":
									bitmapCubeTexture.negativeZ = bitmapData;
							}
							return;
						}
					}
				}
			}
		}

		protected function buildTextureMaterial(bitmapData:BitmapData):TextureMaterial
		{
			var bitmapTexture:BitmapTexture = new BitmapTexture(bitmapData);
			var textureMaterial:TextureMaterial = new TextureMaterial(bitmapTexture);
			return textureMaterial;
		}

		private function get defaultBitmapData():BitmapData
		{
			return BitmapTexture(DefaultMaterialManager.getDefaultTexture()).bitmapData;
		}

		protected function prepareTextureMaterial(url:String):TextureMaterial
		{
			var bitmapTexture:BitmapTexture = new BitmapTexture(defaultBitmapData);
			bitmapTexture.name = url;
			var textureMaterial:TextureMaterial = new TextureMaterial(bitmapTexture);
			loadDependency(url);

			return textureMaterial;
		}

		protected function generateBitmapTexture(url:String):BitmapTexture
		{
			var bitmapTexture:BitmapTexture = new BitmapTexture(defaultBitmapData);
			bitmapTexture.name = url;
			loadDependency(url);
			return bitmapTexture;
		}

		private function finalizeTextureFromID(id:String, bitmapData:BitmapData):void
		{
			var bm:Texture2DBase;
				for(var i:uint = 0;i<_materials.length;++i){

					if(_materials[i] is TextureMaterial){
						bm = TextureMaterial(_materials[i]).texture;
						if(bm.name == id){
							BitmapTexture(bm).bitmapData = bitmapData;
							break;
						}

						if(TextureMaterial(_materials[i]).normalMap){
							bm = TextureMaterial(_materials[i]).normalMap;
							if(bm.name == id){
								BitmapTexture(bm).bitmapData = bitmapData;
								break;
							}
						}

						if(TextureMaterial(_materials[i]).specularMap){
							bm = TextureMaterial(_materials[i]).specularMap;
							if(bm.name == id){
								BitmapTexture(bm).bitmapData = bitmapData;
								break;
							}
						}

					} else{

						if(ColorMaterial(_materials[i]).normalMap){
							bm = ColorMaterial(_materials[i]).normalMap;
							if(bm.name == id){
								BitmapTexture(bm).bitmapData = bitmapData;
								break;
							}
						}

						if(ColorMaterial(_materials[i]).specularMap){
							bm = ColorMaterial(_materials[i]).specularMap;
							if(bm.name == id){
								BitmapTexture(bm).bitmapData = bitmapData;
								break;
							}
						}
					}

			}
		}

		private function loadDependency(url:String, listener:Function = null):void
		{
			var assetLoader:AssetLoader = new AssetLoader();
			assetLoader.addEventListener(AssetEvent.ASSET_COMPLETE, (listener == null)? onAssetComplete: listener);
			assetLoader.load(new URLRequest(url));
		}

		private function onAssetComplete(e:AssetEvent):void
		{
			AssetLoader(e.currentTarget).removeEventListener(AssetEvent.ASSET_COMPLETE, onAssetComplete);
			finalizeTextureFromID(e.assetPrevName, BitmapTexture(e.asset).bitmapData);
		}

		protected function fillData(m:Mesh, mData:Array):void
		{
			for(var i:uint = 0;i<mData.length; i+=5)
				fillSubgeometry(m, mData[i], mData[i+1], mData[i+2], mData[i+3], mData[i+4]);
		}

		protected function buildContainer(rawData:Vector.<Number>, name:String, parent:ObjectContainer3D = null):ObjectContainer3D
		{
			var container:ObjectContainer3D = new ObjectContainer3D();
			var t:Matrix3D = new Matrix3D(rawData);
			container.transform = t;
			container.name = name;
			_containers.push(container);
			if(parent)
				parent.addChild(container);
			else
				addChild(container);

			return container;
		}

		protected function buildMesh(geometry:Geometry, rawData:Vector.<Number>, name:String, material:MaterialBase = null, parent:ObjectContainer3D = null):Mesh
		{
			var mesh:Mesh = new Mesh( geometry, material);
			var t:Matrix3D = new Matrix3D(rawData);
			mesh.transform = t;
			mesh.name = name;
			_meshes.push(mesh);
			if(parent)
				parent.addChild(mesh);
			else
				addChild(mesh);

			return mesh;
		}

		protected function fillSubgeometry(mesh:Mesh, indices:Vector.<uint>, vertices:Vector.<Number>, uvs:Vector.<Number>, normals:Vector.<Number> = null, materialID:String = ""):void
		{
			var subGeom:SubGeometry = new SubGeometry();
			subGeom.updateVertexData(vertices);
			subGeom.updateUVData(uvs);
			subGeom.updateIndexData(indices);
			if(normals){
				subGeom.updateVertexNormalData(normals);
			} else {
				subGeom.autoDeriveVertexNormals = true;
			}
			subGeom.autoDeriveVertexTangents = true;
			mesh.geometry.addSubGeometry(subGeom);
			if(materialID != "") mesh.subMeshes[mesh.subMeshes.length-1].material = getMaterialFromID(materialID);
		}

		public function get containers():Vector.<ObjectContainer3D>
		{
			return _containers;
		}

		public function get materials():Vector.<MaterialBase>
		{
			return _materials;
		}

		public function get meshes():Vector.<Mesh>
		{
			return _meshes;
		}

	}
}